1) Variáveis de ambiente (apenas 1 chave-mestra)

Gera uma chave de 32 bytes e guarda no seu .env do servidor (ou secret do Docker).

# 32 bytes base64 (ex.: openssl rand -base64 32)
MASTER_KEY_BASE64=PUT_AQUI_SUA_CHAVE_32B_BASE64

2) Tabela para segredos

Crie uma tabela simples (exemplo SQL genérico):

CREATE TABLE app_secrets (
  id SERIAL PRIMARY KEY,
  name VARCHAR(64) UNIQUE NOT NULL,
  value_enc TEXT NOT NULL,
  created_at TIMESTAMP DEFAULT NOW(),
  updated_at TIMESTAMP DEFAULT NOW()
);

3) Helper de criptografia (AES-256-GCM)
// src/lib/crypto.ts
import crypto from "crypto";

const key = Buffer.from(process.env.MASTER_KEY_BASE64!, "base64"); // 32 bytes

export function seal(plain: string) {
  const iv = crypto.randomBytes(12);
  const cipher = crypto.createCipheriv("aes-256-gcm", key, iv);
  const enc = Buffer.concat([cipher.update(plain, "utf8"), cipher.final()]);
  const tag = cipher.getAuthTag();
  return Buffer.concat([iv, tag, enc]).toString("base64"); // [12|16|N]
}

export function open(b64: string) {
  const buf = Buffer.from(b64, "base64");
  const iv = buf.subarray(0, 12);
  const tag = buf.subarray(12, 28);
  const enc = buf.subarray(28);
  const decipher = crypto.createDecipheriv("aes-256-gcm", key, iv);
  decipher.setAuthTag(tag);
  const dec = Buffer.concat([decipher.update(enc), decipher.final()]);
  return dec.toString("utf8");
}

4) Rotas de credenciais (admin-only)

POST /admin/rede/credentials: grava PV/Token criptografados.

GET /admin/rede/status: retorna só “configured: true/false”.

NUNCA retornamos o segredo.

// src/routes/admin-rede.ts
import express from "express";
import { seal } from "../lib/crypto";
// use seu ORM/DB aqui
import db from "../db"; // pseudo
import { requireAdmin } from "../middleware/auth"; // garanta RBAC

const router = express.Router();

// status: mostra se já foi cadastrado
router.get("/admin/rede/status", requireAdmin, async (_req, res) => {
  const pv = await db.selectOne("SELECT 1 FROM app_secrets WHERE name='REDE_PV'");
  const tk = await db.selectOne("SELECT 1 FROM app_secrets WHERE name='REDE_TOKEN'");
  res.json({ configured: !!(pv && tk) });
});

// grava PV/Token (sobrescreve/“upsert”)
router.post("/admin/rede/credentials", requireAdmin, express.json(), async (req, res) => {
  const { pv, token } = req.body || {};
  if (!pv || !token) return res.status(400).json({ ok:false, error:"pv e token são obrigatórios" });

  const pvEnc = seal(pv);
  const tkEnc = seal(token);

  await db.tx(async (tx:any) => {
    await tx.run(
      `INSERT INTO app_secrets(name,value_enc) VALUES('REDE_PV', $1)
       ON CONFLICT (name) DO UPDATE SET value_enc=EXCLUDED.value_enc, updated_at=NOW()`, [pvEnc]
    );
    await tx.run(
      `INSERT INTO app_secrets(name,value_enc) VALUES('REDE_TOKEN', $1)
       ON CONFLICT (name) DO UPDATE SET value_enc=EXCLUDED.value_enc, updated_at=NOW()`, [tkEnc]
    );
  });

  // nunca devolva os valores
  res.json({ ok:true, message:"Credenciais salvas com segurança." });
});

export default router;

5) Uso no checkout (cache em memória, nunca expor)
// src/services/rede-secrets.ts
import db from "../db";
import { open } from "../lib/crypto";

let cached: { pv: string; token: string } | null = null;

export async function getRedeSecrets() {
  if (cached) return cached;
  const rowPv = await db.selectOne("SELECT value_enc FROM app_secrets WHERE name='REDE_PV'");
  const rowTk = await db.selectOne("SELECT value_enc FROM app_secrets WHERE name='REDE_TOKEN'");
  if (!rowPv || !rowTk) throw new Error("Credenciais da Rede não configuradas.");
  cached = {
    pv: open(rowPv.value_enc),
    token: open(rowTk.value_enc)
  };
  return cached;
}


E no seu handler de pagamento:

import { getRedeSecrets } from "../services/rede-secrets";

const { pv, token } = await getRedeSecrets();
const authHeader = "Basic " + Buffer.from(`${pv}:${token}`).toString("base64");
// ... segue seu POST /transactions

6) Formulário admin (front) — simples

Página visível só para usuários com papel admin.

// AdminRedeCredenciais.tsx (React)
import { useEffect, useState } from "react";

export default function AdminRedeCredenciais() {
  const [configured, setConfigured] = useState<boolean | null>(null);
  const [pv, setPv] = useState("");
  const [token, setToken] = useState("");
  const [msg, setMsg] = useState("");

  useEffect(() => {
    fetch("/admin/rede/status", { credentials: "include" })
      .then(r => r.json()).then(d => setConfigured(d.configured))
      .catch(() => setConfigured(false));
  }, []);

  async function salvar(e:any) {
    e.preventDefault();
    setMsg("");
    const r = await fetch("/admin/rede/credentials", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      credentials: "include",
      body: JSON.stringify({ pv, token })
    });
    const d = await r.json();
    setMsg(d.ok ? "Salvo com segurança ✅" : (d.error || "Erro"));
    if (d.ok) setConfigured(true);
  }

  return (
    <div className="max-w-md mx-auto p-6 border rounded-xl">
      <h2 className="text-xl font-bold">Credenciais Rede (e.Rede)</h2>
      <p className="text-sm mt-1">
        Status: {configured === null ? "..." : configured ? "Configurado" : "Pendente"}
      </p>
      <form onSubmit={salvar} className="mt-4 space-y-3">
        <input className="w-full border p-2 rounded" placeholder="PV (filiação)"
               value={pv} onChange={e=>setPv(e.target.value)} />
        <input className="w-full border p-2 rounded" placeholder="Token"
               value={token} onChange={e=>setToken(e.target.value)} />
        <button className="w-full p-2 rounded bg-black text-white">Salvar</button>
      </form>
      {msg && <p className="mt-3 text-sm">{msg}</p>}
      <p className="text-xs mt-4 opacity-70">
        Dica: os valores são criptografados no servidor e não ficam visíveis depois de salvos.
      </p>
    </div>
  );
}

Boas práticas rápidas

HTTPS obrigatório na página admin.

RBAC (somente admin pode acessar/POST).

Audit log: registre quem alterou e quando (sem armazenar o valor).

Rate limit e CSRF no POST.

Nunca retorne PV/Token em nenhuma API.

Rotina de rotacionar credenciais (POST novamente sobrescreve).