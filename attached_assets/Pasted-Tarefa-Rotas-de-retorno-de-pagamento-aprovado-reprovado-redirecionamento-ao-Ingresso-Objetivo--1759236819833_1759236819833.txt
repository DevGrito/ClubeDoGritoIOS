Tarefa: Rotas de retorno de pagamento (aprovado/reprovado) + redirecionamento ao Ingresso
Objetivo

Criar rotas de status de pagamento separadas da pÃ¡gina de checkout.

AprovaÃ§Ã£o: mostrar â€œPagamento aprovadoâ€ rapidamente e redirecionar para a pÃ¡gina /ingresso (pÃ³s-compra).

Falha: mostrar â€œOps, nÃ£o conseguimos concluir seu pagamentoâ€ com botÃ£o de tentar novamente que leva ao checkout.

SeguranÃ§a: a decisÃ£o de â€œaprovadoâ€/â€œreprovadoâ€ deve vir do backend (webhook/consulta), nunca sÃ³ do front.

Rotas de Frontend

/pagamento/aprovado

Texto curto â€œPagamento aprovado ğŸ‰â€

Subtexto: â€œSeu ingresso foi liberado.â€

Spinner por 1â€“2s ou botÃ£o â€œVer meu ingresso agoraâ€

AÃ§Ã£o: redirect 1â€“2s â†’ /ingresso

TambÃ©m chama POST /api/pagamentos/confirmar (idempotente) para garantir criaÃ§Ã£o/liberaÃ§Ã£o do ingresso antes do redirect.

/pagamento/reprovado

TÃ­tulo: â€œOps! Pagamento nÃ£o concluÃ­doâ€

Subtexto: â€œNÃ£o conseguimos aprovar seu pagamento.â€

BotÃµes:

Tentar novamente â†’ /ingressos/checkout

(Opcional) â€œTrocar forma de pagamentoâ€ â†’ /ingressos/checkout?method=â€¦

(Opcional) /pagamento/pendente

Para PIX/boletos: â€œPagamento em anÃ¡lise/pendente. Vamos te avisar assim que for aprovado.â€

Poll a cada 5â€“10s em /api/pagamentos/:pedidoId/status.

Quando virar â€œapprovedâ€, redirect â†’ /pagamento/aprovado (e daÃ­ para /ingresso).

ObservaÃ§Ã£o: nÃ£o reaproveitar a rota de checkout. Manter rotas dedicadas de status, como acima.

Contratos de Backend (sugeridos)

Webhook do provedor (Stripe/Pagar.me/MercadoPago/etc.):
POST /api/webhooks/pagamentos

Atualiza o pedido no banco: status âˆˆ {approved, rejected, pending}

Se approved e ainda nÃ£o existir ingresso, cria/autoriza o ingresso do usuÃ¡rio.

Consultar status (para o front conferir):
GET /api/pagamentos/:pedidoId/status â†’ { status: "approved" | "rejected" | "pending" }

Confirmar/garantir ingresso (idempotente):
POST /api/pagamentos/confirmar body: { pedidoId }

Valida no banco se o pedido estÃ¡ approved; se sim, assegura a criaÃ§Ã£o do ingresso.

Responde { ok: true }.

Exemplo (React Router DOM + TS)

Rotas

// src/router.tsx
{ path: "/pagamento/aprovado", element: <PagamentoAprovadoPage /> },
{ path: "/pagamento/reprovado", element: <PagamentoReprovadoPage /> },
{ path: "/pagamento/pendente", element: <PagamentoPendentePage /> }, // opcional


Aprovado â†’ redirecionar ao /ingresso

// src/pages/PagamentoAprovadoPage.tsx
import { useEffect } from "react";
import { useNavigate, useSearchParams } from "react-router-dom";

export default function PagamentoAprovadoPage() {
  const nav = useNavigate();
  const [sp] = useSearchParams();
  const pedidoId = sp.get("pedidoId") ?? "";

  useEffect(() => {
    (async () => {
      try {
        if (pedidoId) {
          await fetch("/api/pagamentos/confirmar", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            credentials: "include",
            body: JSON.stringify({ pedidoId })
          });
        }
      } finally {
        setTimeout(() => nav("/ingresso", { replace: true }), 1500);
      }
    })();
  }, [pedidoId, nav]);

  return (
    <main className="p-6 text-center">
      <h1 className="text-2xl font-extrabold">Pagamento aprovado ğŸ‰</h1>
      <p className="mt-2">Seu ingresso foi liberado. Redirecionandoâ€¦</p>
      <button className="mt-4" onClick={() => nav("/ingresso", { replace: true })}>
        Ver meu ingresso agora
      </button>
    </main>
  );
}


Reprovado â†’ tentar novamente

// src/pages/PagamentoReprovadoPage.tsx
import { useNavigate } from "react-router-dom";

export default function PagamentoReprovadoPage() {
  const nav = useNavigate();
  return (
    <main className="p-6 text-center">
      <h1 className="text-2xl font-extrabold">Ops! Pagamento nÃ£o concluÃ­do</h1>
      <p className="mt-2">NÃ£o conseguimos aprovar seu pagamento.</p>
      <div className="mt-4 flex justify-center gap-3">
        <button onClick={() => nav("/ingressos/checkout")}>Tentar novamente</button>
      </div>
    </main>
  );
}


(Opcional) Pendente com polling

// src/pages/PagamentoPendentePage.tsx
import { useEffect } from "react";
import { useNavigate, useSearchParams } from "react-router-dom";

export default function PagamentoPendentePage() {
  const nav = useNavigate();
  const [sp] = useSearchParams();
  const pedidoId = sp.get("pedidoId") ?? "";

  useEffect(() => {
    let t: any;
    const tick = async () => {
      const r = await fetch(`/api/pagamentos/${pedidoId}/status`, { credentials: "include" });
      const { status } = await r.json();
      if (status === "approved") nav(`/pagamento/aprovado?pedidoId=${pedidoId}`, { replace: true });
      else if (status === "rejected") nav(`/pagamento/reprovado?pedidoId=${pedidoId}`, { replace: true });
      else t = setTimeout(tick, 7000);
    };
    if (pedidoId) tick();
    return () => clearTimeout(t);
  }, [pedidoId, nav]);

  return (
    <main className="p-6 text-center">
      <h1 className="text-xl font-bold">Pagamento em anÃ¡liseâ€¦</h1>
      <p className="mt-2">Assim que for aprovado, te levamos para o seu ingresso.</p>
    </main>
  );
}

IntegraÃ§Ã£o com o Checkout

Configure o provedor de pagamento para retornar o usuÃ¡rio para:

success_url â†’ https://seuapp.com/pagamento/aprovado?pedidoId={ID}

cancel/failure_url â†’ https://seuapp.com/pagamento/reprovado?pedidoId={ID}

(PIX/boletos) pending_url â†’ https://seuapp.com/pagamento/pendente?pedidoId={ID}

Mesmo com success_url, nÃ£o confiar no client: o webhook jÃ¡ terÃ¡ marcado o pedido como approved. A rota /pagamento/aprovado apenas chama POST /api/pagamentos/confirmar por idempotÃªncia e redireciona ao /ingresso.

CritÃ©rios de Aceite

 Rotas criadas: /pagamento/aprovado, /pagamento/reprovado (e /pagamento/pendente, se aplicÃ¡vel).

 success_url/failure_url/pending_url configuradas no provedor para essas rotas.

 Ao entrar em /pagamento/aprovado, o sistema garante a criaÃ§Ã£o/liberaÃ§Ã£o do ingresso e redireciona para /ingresso.

 Em /pagamento/reprovado, hÃ¡ botÃ£o que leva ao /ingressos/checkout.

 Toda decisÃ£o de status vem do backend (webhook/consulta) â€” front nÃ£o confia apenas na querystring.