üß† PROMPT PARA REPLIT AI ‚Äî Diagnosticar e corrigir erro 401 no checkout da Rede (e.Rede)

Quero que voc√™ investigue e corrija o erro de pagamento. No front aparece um toast ‚ÄúErro ao processar pagamento‚Äù e, no console, um POST para /api/pagamentos/rede/checkout retornando 401 (Unauthorized). √Äs vezes as mudan√ßas que voc√™ faz n√£o refletem porque o servidor n√£o reinicia. Fa√ßa tudo abaixo:

1) Identificar a origem do 401

Verifique se o 401 vem do nosso backend (middleware de auth/CORS/CSRF/rota protegida) ou da e.Rede (resposta do endpoint /v1/transactions com Basic Auth inv√°lido).

No handler /api/pagamentos/rede/checkout, registre de forma segura (console.warn) o trio:

source="local" quando quem devolveu 401 foi o nosso servidor (antes de chamar a Rede).

source="erede", status=r.status e body.returnCode/returnMessage quando a e.Rede respondeu 401/4xx.

Nunca logue PV/Token, n√∫mero de cart√£o ou CVV. S√≥ registre orderId, amount, installments, env, e o comprimento dos segredos (ex.: pvLen, tokenLen) para saber se est√£o vazios.

2) Garantir que o backend n√£o bloqueie o checkout

Confirme que NENHUM middleware de autentica√ß√£o de usu√°rio (ex.: requireAdmin, requireAuth, verifica√ß√£o de cookie) esteja protegendo POST /api/pagamentos/rede/checkout. Se estiver, remova a prote√ß√£o apenas desta rota (o checkout deve ser p√∫blico, com valida√ß√£o de payload).

Ajuste CORS:

credentials: true somente se o front usar cookies/sess√£o.

origin igual ao dom√≠nio do app (incluindo o dom√≠nio do Replit se for o caso).

Se houver CSRF, libere essa rota ou inclua cabe√ßalho/ token necess√°rio no fetch do front.

3) Verificar montagem do Basic Auth para a e.Rede

Antes de chamar a e.Rede, recupere PV/Token do servi√ßo de segredos (ou process.env) e valide:

Se ausentes ‚Üí retorne 500 com mensagem clara "Credenciais da Rede n√£o configuradas".

Se presentes ‚Üí monte Authorization: Basic ${base64(PV:Token)}.

Logue apenas pvLen e tokenLen (>0) e env (sandbox|prod).

Garanta que o endpoint est√° correto:

Sandbox: https://sandbox-erede.useredecloud.com.br/v1/transactions

Produ√ß√£o: https://api.userede.com.br/erede/v1/transactions

4) Melhorar mensagens de erro para o front

Quando a e.Rede responder != 2xx, repasse status, returnCode e returnMessage para o front (sanitizados), ex.:

{ "ok": false, "gateway": "erede", "status": 401, "code": "xx", "message": "mensagem da adquirente" }


No caso de erro local (ex.: falta de credencial), retorne:

{ "ok": false, "gateway": "local", "message": "Credenciais da Rede n√£o configuradas" }

5) Checar o front (requisi√ß√£o)

Garanta que o front chama a rota relativa "/api/pagamentos/rede/checkout" (sem dom√≠nio externo) para evitar problemas de CORS/credenciais.

Se o backend depender de sess√£o/cookie, o fetch deve ter credentials: "include".

Valide que os campos enviados s√£o:

{ qty:number>=1, installments:1..10, card:{ cardholderName, cardNumber, expirationMonth, expirationYear, securityCode } }


Mostre no UI a mensagem amig√°vel vinda do backend (message/returnMessage).

6) Rein√≠cio do servidor (Replit)

Se o servidor n√£o estiver reiniciando, ajuste o script dev para usar nodemon/tsx --watch e confira se o Replit est√° usando esse script.

Adicione logs de boot (console.log("[server] started", { env: process.env.REDE_ENV })) para sabermos se reiniciou.

Se necess√°rio, adicione um endpoint de healthcheck GET /health que retorna { ok:true, env, time }.

7) Testes automatizados r√°pidos (manual/cURL)

Implemente um comando npm run test:erede:sanity que:

Checa presen√ßa de PV/Token.

Faz um POST de exemplo para o sandbox com cart√£o dummy (sem expor PAN real) e captura apenas o status/returnMessage.

Adicione no README a instru√ß√£o de rodar esse teste.

8) Checklist de seguran√ßa

N√£o logar dados sens√≠veis (PAN/CVV/PV/Token).

softDescriptor ‚â§ 22 chars (sem acento); cortar caso ultrapasse.

amount sempre em centavos (inteiro).

Parcelas entre 1 e 10 (sem juros no nosso pricing).

9) Entreg√°veis

Commit com mensagem: fix(rede): diagnostico 401, harden checkout, logs seguros, mensagens claras.

Printar no console quando o primeiro pagamento de teste for feito: "[erede] request sent", { orderId, amount, installments, env } e, na resposta, status + returnCode/returnMessage (se houver).

Me mostre (no diff) exatamente:

O middleware/rota onde o 401 local ocorria (se era o caso) e sua corre√ß√£o.

A cria√ß√£o/ajuste do Authorization: Basic e a valida√ß√£o das credenciais.

O tratamento de erro melhorado para o front.

Observa√ß√£o: se o 401 for da e.Rede, a corre√ß√£o provavelmente √© credencial inv√°lida/faltando (PV/Token), endpoint de sandbox errado, ou montagem incorreta do Basic Auth. Se o 401 for local, √© CORS/auth/CSRF/middleware protegendo a rota. Fa√ßa a triagem e a corre√ß√£o completa.